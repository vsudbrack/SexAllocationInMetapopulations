/// # Model for the evolution of sex allocation in the presence of local extinction
initialize()
{
	initializeSLiMModelType("nonWF");
	if (exists("slimgui")) setSeed(0); else setSeed(REPLICATION_NUMBER);
	
	// Demographics	
	defineConstant("NUMBER_DEMES", 200);
	defineConstant("POP_SIZE", 100);
	if (exists("slimgui"))
		defineConstant("F_MAX", 10); // Maximum fecundity of an individual that has z=1
	if (exists("slimgui"))
		defineConstant("DENSITY_DEPENDENT_COMPETITION", T); // Density-competition for resource

	// Migration rates
	defineConstant("MIG_RATE_POLEN", 0.00);
	defineConstant("MIG_RATE_SEEDS", 0.10);
	
	defineConstant("MIG_FACTOR_PHYLO_POLEN", (1 - MIG_RATE_POLEN) );
	defineConstant("MIG_FACTOR_PARA_POLEN", MIG_RATE_POLEN / (NUMBER_DEMES - 1));
	
	// Extinction dynamics
	if (exists("slimgui"))
		defineConstant("DEME_AVERAGE_LIFETIME", 2);
	defineConstant("EXTINCTION_RATE", 1.0 / (1.0 + DEME_AVERAGE_LIFETIME));
	// Recolonization alwys follows the MIGRANT_POOL model
	if (exists("slimgui"))
		defineConstant("RECOLONIZATION_GROUP_SIZE", 1); // k < POP_SIZE
	
	// Genomic information
	defineConstant("GENOME_SIZE", 20); // Number of neutral loci unlinked to sex allocation 
	defineConstant("MUT_RATE_CA", 0.01); // Mutation rate of continum of alleles
	defineConstant("MUT_RATE_NEUTRAL", 1e-4); // Mutation rate of neutral
	defineConstant("MUT_EFFECT_SD", 0.01); // SD of mutation effects
	
	// Selfing rate
	if (exists("slimgui"))
		defineConstant("SELF_RATE", 0.0);
	
	// Seeting the genomes
	defineConstant("RECOMB_RATE", 0.5);
	
	/// ## Chromosome 1 (Selected)
	initializeChromosome(1, symbol="S", name="SELECTED");
	initializeMutationRate(MUT_RATE_CA);
	initializeMutationType("m1", 0.5, "n", 0.0, MUT_EFFECT_SD); // QTLs
	m1.convertToSubstitution = F;
	m1.mutationStackPolicy = "l";
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 0);
	initializeRecombinationRate(RECOMB_RATE);
	
	/// ## Chromosome 2 (Non-Selected)
	initializeChromosome(2, symbol="NS", name="NEUTRAL");
	initializeMutationRate(MUT_RATE_NEUTRAL);
	initializeMutationType("m0", 0.5, "f", 0.0); // Neutral allele
	m0.convertToSubstitution = F;
	m0.mutationStackPolicy = "l";
	initializeGenomicElementType("g2", m0, 1.0);
	initializeGenomicElement(g2, 0, GENOME_SIZE - 1);
	initializeRecombinationRate(RECOMB_RATE);
	
	// Outputs
	defineGlobal("MEAN_PHENO", NAN);
	defineGlobal("MEAN_PHENO_EXPECTED", 0.5 * (1 + SELF_RATE + (1 - SELF_RATE) / POP_SIZE));
	defineGlobal("MEAN_PHENO_EXPECTED_EXCT", 0.5 * (1 + SELF_RATE + (EXTINCTION_RATE + 2 * MIG_RATE_SEEDS - MIG_RATE_POLEN) * (POP_SIZE * EXTINCTION_RATE + RECOLONIZATION_GROUP_SIZE) / POP_SIZE / (EXTINCTION_RATE * (RECOLONIZATION_GROUP_SIZE - 1) + (2 * MIG_RATE_SEEDS + MIG_RATE_POLEN) * RECOLONIZATION_GROUP_SIZE)));
	
	// Plotting the phenotypes
	if (exists("slimgui"))
	{
		plot = slimgui.createPlot(title="Phenotypes", xrange=c(-1, 8e3), yrange=c(0, 1), xlab="Time", ylab="Allocation", width=400, height=400, fullBox=F);
		plot.abline(a=ifelse(EXTINCTION_RATE > 0, MEAN_PHENO_EXPECTED_EXCT, MEAN_PHENO_EXPECTED), b=0, color="darkgray");
	}
	else
	{
		writeFile(filename('all'), "#" + date() + " " + time());
	}
}

/***/
/// ## Mutation
mutation(m1) /* Continuum of alleles */
{
	parentalMut = haplosome.mutationsOfType(m1);
	if (size(parentalMut) == 0) return T;
	
	prev = parentalMut.selectionCoeff;
	mut.setSelectionCoeff(min(1.0, max(0.0, prev + mut.selectionCoeff)));
	return T;
}

mutationEffect(m1) { return 1.0; }

/***/
/// ## Initialization
1 first()
{
	// Start populations
	for (i in 1:NUMBER_DEMES)
		sim.addSubpop(i, POP_SIZE);
	
	// Set age of the new adults by hand
	sim.subpopulations.individuals.age = 1;
	
	// Start all Sex Allocation alleles randomly between 0 and 1
	for (haplo1 in sim.subpopulations.haplosomesForChromosomes(1))
		haplo1.addNewMutation(m1, runif(1, 0.0, 1.0), 0);
	//haplo1.addNewMutation(m1, 0.5, 0);
	
	// Start all neutral alleles as heterozygotes
	haplo2 = sim.subpopulations.haplosomesForChromosomes(2);
	haplo2.addNewDrawnMutation(m0, seqLen(GENOME_SIZE));
	
	// Start plot
	inds = sim.subpopulations.individuals;
	inds.tagF = sapply(inds, "getAllocationFromGenotype(applyValue);");
	defineGlobal("MEAN_PHENO", mean(inds.tagF));
	//if (exists("slimgui")) updatePhenoPlot(0);
}

/***/
/// ## Extinctions
first() /* Choose demes to go extinct and kill individuals in these demes */
{
	// Reset all subpopulation tags to PopSize
	sim.subpopulations.tag = POP_SIZE;
	
	// Sample number of demes going extinct
	nExt = rbinom(1, NUMBER_DEMES, EXTINCTION_RATE);
	
	// Skip if there is no extinctions
	if (nExt == 0) return;
	
	// Sample populations that are going extinct uniformly at random
	popExt = sample(sim.subpopulations, nExt);
	
	// Set tag of extinct demes to K
	popExt.tag = RECOLONIZATION_GROUP_SIZE;
	
	// Kill individuals in extinct demes
	sim.killIndividuals(popExt.individuals);
	
	// Check if population didn't go extinct
	popsize = size(sim.subpopulations.individuals);
	if(popsize == 0) stop("The population went extinct.");
}

/***/
/// ## Phenotypes
first() /* Calculating traits before Reproduction() */
{
	inds = sim.subpopulations.individuals;
	inds.tagF = sapply(inds, "getAllocationFromGenotype(applyValue);");
	
	// Calculates population mean and variances
	zs = inds.tagF;
	defineGlobal("MEAN_PHENO", mean(zs));
	defineGlobal("VART_PHENO", var(zs));
}

/***/
/// ## Reproduction
reproduction() /* Production of seeds */
{
	// If this individual doesn't produce seeds (pure males), exit reproduction()
	if (individual.tagF == 0.0) return;
	
	// Get the number of seeds produced by this individual
	baselineFecundity = F_MAX * ifelse(DENSITY_DEPENDENT_COMPETITION, 1.0 / subpop.individualCount, 1.0);	
	nbSeeds = getNumberOfSeedsProduced(baselineFecundity * individual.tagF);
	
	// Determines number of selfed and outcrossed seeds
	nbSeedsSelfed = rbinom(1, nbSeeds, SELF_RATE);
	nbSeedsOutcrossed = nbSeeds - nbSeedsSelfed;
	
	// Add all selfed offspring
	if (nbSeedsSelfed > 0) subpop.addSelfed(individual, count = nbSeedsSelfed);
	
	// If no outcrossing, ready to exit reproduction()
	if (nbSeedsOutcrossed == 0) return;
	
	// Add all outcrossed offspring: sample fathers
	fathers = getFathersForMother(individual, nbSeedsOutcrossed);
	
	if (size(fathers)>0) for (father in fathers) subpop.addCrossed(individual, father);
}

early() /* Immediatly after reproduction, all adults die (no overlapping generations) */
{
	adults = sim.subpopulations.subsetIndividuals(minAge=1);
	sim.killIndividuals(adults);
}

/***/
/// ## Seed dispersal and recolonization
early()/* Disperse resident seeds patch per patch */
{
	// Get number of seeds produced
	nbSeeds = sum(sim.subpopulations.individualCount);
	
	// Samples the number of seeds that will dispersal
	nbMigrantingSeeds = rbinom(1, nbSeeds, MIG_RATE_SEEDS);
	
	// If no seed disperses, skip population
	if (nbMigrantingSeeds == 0) next;
	
	// Sample dispersing seeds and their destination
	migratingSeed = sample(sim.subpopulations.individuals, nbMigrantingSeeds, replace=F);
	destinySubpop = sample(sim.subpopulations, nbMigrantingSeeds, replace=T);
	
	// Migrates
	for (seed in migratingSeed, destiny in destinySubpop) destiny.takeMigrants(seed);
}

/***/
/// ## Survival and regulation
early() /* Define whether individuals survive or not (store in tagL0) */
{
	sim.subpopulations.individuals.tagL0 = F;
	for(pop in sim.subpopulations) pop.sampleIndividuals(pop.tag).tagL0 = T;	
}

survival() { return individual.tagL0; }

/***/
/// ## Analysis
late()
{
	
	if (sim.cycle % 50 != 0)
		return;
	
	if (exists("slimgui"))
	{
		updatePhenoPlot(sim.cycle);
		fs = calc_Fstats(tableFormat=T);
		catn(fs);
	}
	else
	{
		fs = paste(c(sim.cycle, popsize, MEAN_PHENO, VART_PHENO, calc_Fstats()));
		writeFile(filename('all'), fs, append=T);
	}
}

// End the simulation
5e4 late() { sim.simulationFinished(); }

/***/
/// ## Functions
function (float$)getAllocationFromGenotype(o<Individual>$ focal)
{
	z = focal.sumOfMutationsOfType(m1);
	return z / 2.0;
}

function (integer$)getNumberOfSeedsProduced(numeric$ fecundity) {
	n = rpois(1, fecundity);
	//dn = fecundity - floor(fecundity);
	//n = floor(fecundity) + sample(c(0, 1), 1, weights=c(1.0-dn, dn));
	return asInteger(n);
}

function (No<Individual>)getFathersForMother(o<Individual>$ mother, integer$ nbSeedsOutcrossed)
{
	maternalPop = mother.subpopulation;
	
	// No polen dispersal, local sampling (for optimization purposes only)
	if (MIG_RATE_POLEN == 0.0){
		indsWithinDeme = maternalPop.subsetIndividuals(minAge=1);
		
		// If there is no polen within the deme, return NULL
		//if (all(indsWithinDeme.tagF >= 0.99)) return NULL;
		
		return sample(indsWithinDeme, nbSeedsOutcrossed, replace=T, weights=1.0 - indsWithinDeme.tagF);
	}
	
	inds = sim.subpopulations.subsetIndividuals(minAge=1);
	allXM = 1.0 - inds.tagF;
	migFactorPolen = rep(MIG_FACTOR_PARA_POLEN, size(inds));
	migFactorPolen[inds.subpopulation == maternalPop] = MIG_FACTOR_PHYLO_POLEN;
	fathers = sample(inds, nbSeedsOutcrossed, replace=T, weights=migFactorPolen*allXM);
	
	return fathers;
}


function (void)updatePhenoPlot(integer gen)
{
	plot = slimgui.plotWithTitle("Phenotypes");
	phenos = sapply(sample(sim.subpopulations.individuals, 500, replace=T), "getAllocationFromGenotype(applyValue);");
	plot.points(gen + runif(length(phenos), 0, 50), phenos, symbol=16, size=0.1);
	plot.lines(c(gen, gen + 49), rep(MEAN_PHENO, 2), color="blue", lwd=3.0);
}

function (string)filename(string id)
{
	x = "/work/FAC/FBM/DEE/cmullon/default/sexAllocation/Trait_FiniteSeeds_";
	
	//x = "~/Downloads/Trait_"; // change this line for filename and folder place
	x = x + REPLICATION_NUMBER + "_";
	if (id == 'all')
		x = x + "allInfo";
	x = x + "_selfing=" + SELF_RATE + "_Lneutral=" + GENOME_SIZE;
	x = x + "_lifetimeDeme=" + DEME_AVERAGE_LIFETIME + "_k=" + RECOLONIZATION_GROUP_SIZE + "_N=" + POP_SIZE;
	x = x + "_migrant" + "_dPolen=" + MIG_RATE_POLEN + "_dSeeds=" + MIG_RATE_SEEDS;
	x = x + "_Fmax=" + F_MAX + ifelse(DENSITY_DEPENDENT_COMPETITION, "_DD=1", "_DD=0");
	return x + "_.txt";
}

/***/
/// ## Probabilities of coalescence (Q1, Q2, and Q3)
function (float)calc_Q1(integer pos){
	q1 = 1.0 - calc_HO(pos);
	return q1;
}

function (float)calc_Q2(integer pos){
	muts = sim.mutationsOfType(m0);
	muts = muts[muts.position == pos];
	
	sumPijk = sapply(sim.subpopulations, "sum(sim.mutationFrequencies(applyValue, muts)^2.0);" );

	Nj = sim.subpopulations.individualCount;
	weightNj = Nj*(2.0*Nj - 1.0);
	
	sumPijk = sumPijk[weightNj > 0];
	weightNj = weightNj[weightNj > 0];
	
	q2 = sum(weightNj*sumPijk)/sum(weightNj);
	return q2;
}

function (float)calc_Q3(integer pos){
	muts = sim.mutationsOfType(m0);
	muts = muts[muts.position == pos];
	pij = sim.mutationFrequencies(NULL, muts);
	return sum(pij ^ 2.0);
}

function (float)calc_Nc(integer pos){
	muts = sim.mutationsOfType(m0);
	muts = muts[muts.position == pos];
	
	if (size(muts) <= 1) return 0.0; // No mutation segregating
	
	nik = sim.subpopulations.individuals.haplosomesForChromosomes(2).mutationCountsInHaplosomes(muts);
	S1 = sum(nik); // Always = 2N?
	S2 = sum(nik^2.0);
	return (S1-S2/S1)/(size(muts)-1);
}

/***/
/// ## Calculate heterozygosities
function (float)calc_HO(integer pos){
	inds = sim.subpopulations.individuals;
	het = sapply(inds, "calcPairHeterozygosity(applyValue.haplosomesForChromosomes(2, 0), applyValue.haplosomesForChromosomes(2, 1), start=pos, end=pos, infiniteSites = F);");
	Ho = mean(het);
	return Ho;
}

function (float)calc_HS(integer pos){
	muts = sim.mutationsOfType(m0);
	mutsPos = muts[muts.position == pos];
	Hs = sapply(sim.subpopulations, "1.0 - sum(sim.mutationFrequencies(applyValue, mutsPos)^2);");
	return mean(Hs);
}

function (float)calc_HT(integer pos){
	muts = sim.mutationsOfType(m0);
	mutsPos = muts[muts.position == pos];
	Ht = 1.0 - sum(sim.mutationFrequencies(NULL, mutsPos)^2);
	return Ht;
}

/***/
/// ## F-statistics
function (sf)calc_Fstats([logical$ tableFormat=F])
{
	// Compute the probabilities Qi for each position
	q1 = sapply(seqLen(GENOME_SIZE), "calc_Q1(applyValue);");
	q2 = sapply(seqLen(GENOME_SIZE), "calc_Q2(applyValue);");
	q3 = sapply(seqLen(GENOME_SIZE), "calc_Q3(applyValue);");
	nc = sapply(seqLen(GENOME_SIZE), "calc_Nc(applyValue);");
	
	// Compute F-statistics using Qi's
	// Compute FIS
	denom = sum(nc * (1.0 - q2));	
	FIS = ifelse(denom < 1e-8, NAN, sum((nc*(q1-q2)))/denom);
	
	// Compute FST
	denom = sum(nc * (1.0 - q3));	
	FST = ifelse(denom < 1e-8, NAN, sum((nc*(q2-q3)))/denom);

	// Compute FST
	FIT = ifelse(denom < 1e-8, NAN, sum((nc*(q1-q3)))/denom);
	
	// Build a formatted table for display
	if (tableFormat)
	{
		string = "F-Statistics for population at gen. " + sim.cycle + "\n";
		string = string + "-----------------------------------------\n";
		string = string + format("  FIS :  %.3f\n", FIS);
		string = string + format("  FST :  %.3f\n", FST);
		string = string + format("  FIT :  %.3f\n", FIT);
		string = string + "-----------------------------------------";
		return string;
	}
	else
	{
		return c(FIS, FST, FIT);
	}
}
